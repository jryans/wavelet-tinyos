
<html>
<head>
<title>Component: StateM</title>
</head>
<body>
<table BORDER="0" CELLPADDING="3" CELLSPACING="0" width="100%">
<tr><td>
<font size="-1">
<b><font color="blue"><a href="apps_p.html">Apps</a></font></b>
&nbsp;&nbsp;&nbsp;
<b><a href="components_p.html">Components</a></b>
&nbsp;&nbsp;&nbsp;
<b><a href="interfaces_p.html">Interfaces</a></b>
&nbsp;&nbsp;&nbsp;
<b><a href="allfiles_p.html">All Files</a></b>
&nbsp;&nbsp;&nbsp;
<b><a href="index.html">Source Tree</a></b>
&nbsp;&nbsp;&nbsp;
</font>
</td>
<td align="right">
<font size="-1">
source: <b><a href="tos.lib.State.StateM.nc.source">tos.lib.State.StateM.nc</a></b>
</font>
</td></tr></table>
<hr>

<h1 align="center">Component: StateM</h1>
<p>


 This is a parameterized state controller for any and every component's

 state machine(s).



 There are several compelling reasons to use the State module/interface

 in all your components that have any kind of state associated with them:



   1) It provides a unified interface to control any state, which makes

      it easy for everyone to understand your code

   2) You can easily keep track of multiple state machines in one component

   3) You could have one state machine control several components



 Connect your component's State interface to StateM.State[unique("State")]; 

 when creating a new state machine. If two components share the same states, 

 use one unique("State") for both.



 Keep in mind, S_IDLE is always 0.

 

 <table border="0" cellpadding="0">
<tr valign="top"><td><b>Author:</b>
<td> david moss -> <a href="mailto:dmm@rincon.com">dmm@rincon.com</a>

</td></tr></table>

<p>

<table BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<tr BGCOLOR="#CCCCFF"><td>
<h3>Provided Interfaces</h3></td></tr></table>
<ul>
<li>    <a href="tos.lib.State.State.nc.html">State</a> 
<li>    <a href="tos.interfaces.StdControl.nc.html">StdControl</a> 
</ul>

<table BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<tr BGCOLOR="#CCCCFF"><td>
<h3>Variables</h3></td></tr></table>
<ul>
<li>   uint8_t state[3U]
        <br><menu> Each component's state </menu>
</ul>

<table BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<tr BGCOLOR="#CCCCFF"><td>
<h3>Function Index</h3></td></tr></table>
<ul>
<li>
        command result_t     <a href="tos.interfaces.StdControl.nc.html#command result_t StdControl.init(void)">
<b>StdControl.init</b>    </a>
(void)
<menu>*************** StdControl Commands ***************</menu><p>

<li>
        command result_t     <a href="tos.interfaces.StdControl.nc.html#command result_t StdControl.start(void)">
<b>StdControl.start</b>    </a>
(void)

<li>
        command result_t     <a href="tos.interfaces.StdControl.nc.html#command result_t StdControl.stop(void)">
<b>StdControl.stop</b>    </a>
(void)

<li>
        command result_t     <a href="#command result_t State.requestState(uint8_t id, uint8_t reqState)">
<b>State.requestState</b>    </a>
(uint8_t id, uint8_t reqState)
<menu>

 This will allow a state change so long as the current

 state is S_IDLE.

</menu><p>

<li>
        command result_t     <a href="tos.lib.State.State.nc.html#command result_t State.forceState(uint8_t id, uint8_t reqState)">
<b>State.forceState</b>    </a>
(uint8_t id, uint8_t reqState)
<menu>

 Force the state machine to go into a certain state,

 regardless of the current state it's in.

</menu><p>

<li>
        command result_t     <a href="tos.lib.State.State.nc.html#command result_t State.toIdle(uint8_t id)">
<b>State.toIdle</b>    </a>
(uint8_t id)
<menu>

 Set the current state back to S_IDLE

</menu><p>

<li>
        command bool     <a href="#command bool State.isIdle(uint8_t id)">
<b>State.isIdle</b>    </a>
(uint8_t id)
<menu>

</menu><p>

<li>
        command uint8_t     <a href="tos.lib.State.State.nc.html#command uint8_t State.getState(uint8_t id)">
<b>State.getState</b>    </a>
(uint8_t id)
<menu>

 Get the current state

</menu><p>

</ul>

<table BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<tr BGCOLOR="#CCCCFF"><td>
<h3>Function Descriptions</h3>
</td></tr></table>
    <a name="command result_t State.requestState(uint8_t id, uint8_t reqState)"></a>
        <h4>State.requestState</h4>
        command result_t     <a href="tos.lib.State.State.nc.html#command result_t State.requestState(uint8_t id, uint8_t reqState)"><b>State.requestState</b>    </a>
(uint8_t id, uint8_t reqState)<P><menu>

 This will allow a state change so long as the current

 state is S_IDLE.

 <table border="0" cellpadding="0">
<tr valign="top"><td><b>Returns:</b></td>
<td> SUCCESS if the state is change, FAIL if it isn't

</td></tr></table>
</menu><hr>
    <a name="command bool State.isIdle(uint8_t id)"></a>
        <h4>State.isIdle</h4>
        command bool     <a href="tos.lib.State.State.nc.html#command bool State.isIdle(uint8_t id)"><b>State.isIdle</b>    </a>
(uint8_t id)<P><menu>

 <table border="0" cellpadding="0">
<tr valign="top"><td><b>Returns:</b></td>
<td> TRUE if the state machine is in S_IDLE

</td></tr></table>
</menu>